/*
 * verilog_emit.h - Verilog Backend Emission (TASK-017)
 *
 * Converts compiled ternary bytecode into a Verilog testbench
 * that exercises the ternary ALU. This allows verifying that
 * the hardware module produces the same results as the C VM.
 */

#ifndef VERILOG_EMIT_H
#define VERILOG_EMIT_H

#include <stdio.h>
#include "vm.h"

/*
 * Emit a Verilog testbench that replays the given bytecode
 * on the ternary_processor module. Writes to the specified file.
 * Returns 0 on success, -1 on error.
 */
static inline int emit_verilog_testbench(const unsigned char *code, int len,
                                          const char *output_path) {
    FILE *f = fopen(output_path, "w");
    if (!f) return -1;

    fprintf(f, "/*\n * Auto-generated Verilog testbench\n");
    fprintf(f, " * Generated by ternary_compiler --emit-verilog\n */\n\n");
    fprintf(f, "`timescale 1ns/1ps\n\n");
    fprintf(f, "module auto_tb;\n");
    fprintf(f, "    reg clk, rst;\n");
    fprintf(f, "    reg [7:0] instr, operand;\n");
    fprintf(f, "    wire [17:0] tos;\n");
    fprintf(f, "    wire halted;\n\n");
    fprintf(f, "    ternary_processor u_proc(\n");
    fprintf(f, "        .clk(clk), .rst(rst),\n");
    fprintf(f, "        .instruction(instr), .operand(operand),\n");
    fprintf(f, "        .top_of_stack(tos), .halted(halted)\n");
    fprintf(f, "    );\n\n");
    fprintf(f, "    always #5 clk = ~clk;\n\n");
    fprintf(f, "    initial begin\n");
    fprintf(f, "        $display(\"=== Auto-generated Testbench ===\");\n");
    fprintf(f, "        clk = 0; rst = 1;\n");
    fprintf(f, "        instr = 0; operand = 0;\n");
    fprintf(f, "        #10; rst = 0;\n\n");

    /* Emit instruction sequence */
    for (int i = 0; i < len; ) {
        unsigned char op = code[i++];
        switch (op) {
            case OP_PUSH:
                if (i < len) {
                    fprintf(f, "        // PUSH %d\n", (int)(signed char)code[i]);
                    fprintf(f, "        instr = 8'd0; operand = 8'd%u;\n",
                            code[i]);
                    i++;
                }
                break;
            case OP_ADD:
                fprintf(f, "        // ADD\n");
                fprintf(f, "        instr = 8'd1; operand = 8'd0;\n");
                break;
            case OP_MUL:
                fprintf(f, "        // MUL\n");
                fprintf(f, "        instr = 8'd2; operand = 8'd0;\n");
                break;
            case OP_SUB:
                fprintf(f, "        // SUB (a-b via ALU)\n");
                fprintf(f, "        instr = 8'd3; operand = 8'd0;\n");
                break;
            case OP_HALT:
                fprintf(f, "        // HALT\n");
                fprintf(f, "        instr = 8'd5; operand = 8'd0;\n");
                break;
            default:
                fprintf(f, "        // OP %d (unsupported in Verilog)\n", op);
                fprintf(f, "        instr = 8'd255; operand = 8'd0;\n");
                break;
        }
        fprintf(f, "        @(posedge clk); #1;\n\n");
    }

    fprintf(f, "        // Wait for halt\n");
    fprintf(f, "        #20;\n");
    fprintf(f, "        $display(\"Result TOS: %%b\", tos);\n");
    fprintf(f, "        $display(\"Halted: %%b\", halted);\n");
    fprintf(f, "        $finish;\n");
    fprintf(f, "    end\n");
    fprintf(f, "endmodule\n");

    fclose(f);
    return 0;
}

#endif /* VERILOG_EMIT_H */
